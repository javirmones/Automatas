package teoria_automatas;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Hashtable;


parser code {:

public void report_error(String message, Object info) {

/*Parafernalia de pepe castro para pillar errores....*/
        StringBuffer m = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la linea "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", columna "+(s.right+1));
            }
        }

        m.append(" : "+message);

        System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void syntax_error(Symbol s){
        System.out.println("Error recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error no recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }



:}

action code {:

:}

non terminal programa, dec_metodos, metodos, dec_args, cuerpo_metodo, dec_for, dec_ops, dec_call_loop, dec_asig_ops,
dec_for_loop, dec_asigs, dec_call, dec_return, cuerpo_for, for_st_1, for_st_2, for_st_3, init_for, dec_call_args;


terminal String LL_OP, LL_CL, FOR ,ID, TIPOS_VAR, RETURN, PUNTOCOMA, B;
terminal String RELACIONALES, ASIGNACION, INCREMENTO, DECREMENTO, ARIT, PAR_OP, PAR_CL, COMA, NUM;
terminal String BEGIN_METODOS, TIPOS_MET, BOOLEANOS, LOGICOS_B, LOGICOS_U;


programa ::= dec_metodos ;

/*Para poder generar los metodos de 1 a N veces*/
dec_metodos ::= metodos | metodos dec_metodos;

metodos ::= BEGIN_METODOS TIPOS_MET ID PAR_OP dec_args PAR_CL LL_OP cuerpo_metodo LL_CL;

/*Argumentos de los métodos de 1 a N veces*/
dec_args ::= TIPOS_VAR ID | TIPOS_VAR ID COMA dec_args;

/*El cuerpo de los metodos es lo que queramos meterle dentro*/
cuerpo_metodo ::= ;

/*Repeticiones de for */
dec_for_loop ::= dec_for | dec_for dec_for_loop;

/*Realizamos aqui la declaracion de uno o muchos bucles for*/
dec_for ::= FOR init_for LL_OP cuerpo_for LL_CL ;

/*El contenido del bucle (   A  ; B ;  C ) donde A = for_st_1, B = for_st_2 y C = for_st_3 */
init_for ::= PAR_OP for_st_1 PUNTOCOMA for_st_2 PUNTOCOMA for_st_3 PAR_CL;

for_st_1 ::= TIPOS_VAR ID ASIGNACION ID | ID ASIGNACION ID;

for_st_2 ::= ID RELACIONALES ID;

for_st_3 ::= ID INCREMENTO | ID DECREMENTO;

cuerpo_for ::= dec_asigs dec_call_loop;

dec_asig_ops ::= ID ASIGNACION ID ARIT ID PUNTOCOMA;

/* Asignaciones tipo int a = 0;  boolean asdf = true; */
dec_asigs ::= TIPOS_VAR ID ASIGNACION ID PUNTOCOMA
            | TIPOS_VAR ID PUNTOCOMA
            | TIPOS_VAR ID ASIGNACION BOOLEANOS PUNTOCOMA;

/* Repetir las llamadas a los métodos */
dec_call_loop ::= dec_call | dec_call dec_call_loop;

/*Aqui pretendo construir sintácticamente las llamadas tipo a = calculo(val) o mostrartal(e, a )*/ 
dec_call ::= TIPOS_VAR ID ASIGNACION ID PAR_OP dec_call_args PAR_CL PUNTOCOMA 
            |  ID ASIGNACION ID PAR_OP dec_call_args PAR_CL PUNTOCOMA
            |  ID PAR_OP dec_call_args PAR_CL PUNTOCOMA ;

/* Construcciones de variables */
dec_call_args ::= ID | ID COMA dec_call_args; 

/*Aqui pretendo construir la finalización de los metodos que puedan retornar, sintácticamente
no influye que se pueda construir un método void con return ya que eso se comprueba en el  A. semántico*/
dec_return ::= RETURN ID PUNTOCOMA | RETURN BOOLEANOS PUNTOCOMA | RETURN dec_ops PUNTOCOMA | ;

/*Aqui pretendo implementar operaciones de tipo (x<3) && !true */

