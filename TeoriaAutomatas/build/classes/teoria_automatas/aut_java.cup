package teoria_automatas;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Hashtable;


parser code {:

public void report_error(String message, Object info) {

/*Parafernalia de pepe castro para pillar errores....*/
        StringBuffer m = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la linea "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", columna "+(s.right+1));
            }
        }

        m.append(" : "+message);

        System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void syntax_error(Symbol s){
        System.out.println("Error recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error no recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }



:}

action code {:

:}

non terminal programa, dec_metodos, metodos, dec_args, args, cuerpo_metodo, dec_for, dec_ops,
 dec_asigs, dec_call, dec_return, cuerpo_for, for_st_1, for_st_2, for_st_3, init_for;


terminal String LL_OP, LL_CL, FOR ,ID, TIPOS_VAR, RETURN, PUNTOCOMA,
RELACIONALES, ASIGNACION, INCREMENTO, DECREMENTO, ARIT, PAR_OP, PAR_CL, COMA, NUM,
BEGIN_METODOS, TIPOS_METODOS, BOOLEANOS, LOGICOS_B, LOGICOS_U;


programa ::= dec_metodos ;

/*Para poder generar los metodos de 1 a N veces*/
dec_metodos ::= metodos | metodos dec_metodos;

metodos ::= BEGIN_METODOS TIPOS_METODOS ID PAR_OP dec_args PAR_CL LL_OP cuerpo_metodo LL_CL;

/*Argumentos de los métodos de 1 a N veces*/
dec_args ::= args | args dec_args;

/*Los argumentos se definen como int hola, int adios*/
args ::= TIPOS_VAR ID | COMA TIPOS_VAR ID;


/*El cuerpo de los metodos es lo que queramos meterle dentro*/
cuerpo_metodo ::= dec_for dec_asigs dec_call dec_ops dec_return;

/*Realizamos aqui la declaracion de uno o muchos bucles for*/
dec_for ::= FOR init_for LL_OP cuerpo_for LL_CL |
             FOR init_for LL_OP cuerpo_for dec_for LL_CL ;

/*El contenido del bucle (   A  ; B ;  C ) donde A = for_st_1, B = for_st_2 y C = for_st_3 */
init_for ::= PAR_OP for_st_1 PUNTOCOMA for_st_2 PUNTOCOMA for_st_3 PAR_CL;

for_st_1 ::= TIPOS_VAR ID ASIGNACION ID | ID ASIGNACION ID;

for_st_2 ::= ID RELACIONALES ID;

for_st_3 ::= ID INCREMENTO | ID DECREMENTO;

cuerpo_for ::= dec_asigs dec_call;

dec_asigs ::= TIPOS_VAR ID ASIGNACION ID PUNTOCOMA | TIPOS_VAR ID ASIGNACION BOOLEANOS PUNTOCOMA;

/*Aqui pretendo construir sintácticamente las llamadas tipo a = calculo(val) o mostrartal(e, a )*/ 
dec_call ::=;

/*Aqui pretendo construir la finalización de los metodos que puedan retornar, sintácticamente
no influye que se pueda construir un método void con return ya que eso se comprueba en el  A. semántico*/
dec_return ::= RETURN ID PUNTOCOMA | RETURN BOOLEANOS PUNTOCOMA | RETURN dec_ops PUNTOCOMA;


/*Aqui pretendo implementar operaciones de tipo (x<3) && !true */
dec_ops ::= NUM ;
