package teoria_automatas;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Hashtable;


parser code {:

public void report_error(String message, Object info) {

        StringBuffer m = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la linea "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", columna "+(s.right+1));
            }
        }

        m.append(" : "+message);

        System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) {
        System.out.println("Análisis incorrecto");
        report_error(message, info);
        System.exit(1);
    }

:}

action code {:

:}

non terminal dec_metodos, metodos, dec_args, cuerpo_metodo, dec_for, type_boolean, for_st_aux, fin;
non terminal type_methods, type_vars, dec_asigs, dec_call,for_st_arrays, dec_exp,dec_exp_extra,dec_exp_aux, bloque_inst, inst, inst_for, bloque_inst_for;
non terminal dec_return, cuerpo_for, for_st_1, for_st_2, for_st_3, init_for, dec_call_args;

terminal String LL_OP, LL_CL, FOR ,ID, RETURN, PUNTOCOMA, NUM, PUNTO, OR, DISTINTO, DECREMENT;
terminal String RELACIONALES, ASIGNACION, INCREMENT, PAR_OP, PAR_CL, COMA, POR, DIV, MENOS, MAS;
terminal String BEGIN_METODOS, LOGICOS_B, LOGICOS_U, BOOLEAN, TRUE, FALSE, INT, VOID;

/*Inicio de la gramática*/
/*Para poder generar los metodos de 1 a N veces*/
dec_metodos ::= metodos | metodos dec_metodos;

/*Declaracion de metodos*/
metodos ::= BEGIN_METODOS type_methods ID PAR_OP dec_args PAR_CL LL_OP cuerpo_metodo LL_CL;
            
/*Argumentos de los métodos de 1 a N veces o ninguna*/
dec_args ::= type_vars ID | type_vars ID COMA dec_args | ;

/*El cuerpo de los metodos es lo que queramos meterle dentro*/
cuerpo_metodo ::= bloque_inst |  ;    

/*Bloque de instrucciones*/
bloque_inst ::= inst | inst bloque_inst;

/*Declaracion de instrucciones*/
inst ::= dec_for | dec_call | dec_asigs | dec_return ;

/*Realizamos aqui la declaracion de uno o muchos bucles for uno dentro de otro*/
dec_for ::= FOR PAR_OP init_for PAR_CL LL_OP cuerpo_for dec_for LL_CL
           | FOR PAR_OP init_for PAR_CL LL_OP cuerpo_for LL_CL ;

/*El contenido del bucle (   A  ; B ;  C ) donde A = for_st_1, B = for_st_2 y C = for_st_3 */
init_for ::= for_st_1 PUNTOCOMA for_st_2 PUNTOCOMA for_st_3 ;

for_st_1 ::=  type_vars ID ASIGNACION for_st_aux | ID ASIGNACION for_st_aux ;

for_st_aux ::= ID | NUM;

for_st_2 ::= ID RELACIONALES for_st_arrays;

for_st_arrays ::= ID PUNTO ID PAR_OP PAR_CL | ID;

/* Problemas con el --*/
for_st_3 ::= ID INCREMENT | ID "--";

/* Contenido del bucle for (Hay que meter asignaciones, llamadas y )*/
cuerpo_for ::= bloque_inst_for | ;

bloque_inst_for ::= inst_for | inst_for bloque_inst_for;

inst_for ::= dec_call | dec_asigs; 

/* Asignaciones, declaraciones to padentro tipo int a = 0;  boolean asdf = true; o int a; */
dec_asigs ::= type_vars ID PUNTOCOMA
              | type_vars ID ASIGNACION dec_exp PUNTOCOMA;
       
/*Aqui pretendo construir sintácticamente las llamadas tipo a = calculo(val) o mostrartal(e, a )*/ 
dec_call ::=  ID ASIGNACION ID PAR_OP dec_call_args PAR_CL PUNTOCOMA 
             | ID PAR_OP dec_call_args PAR_CL PUNTOCOMA
             | type_vars ID ASIGNACION ID PAR_OP dec_call_args PAR_CL PUNTOCOMA
             | ID ASIGNACION dec_exp PUNTOCOMA;
          
/* Construcciones de argumentos de llamadas a metodos a, b, c o a o lambda*/
dec_call_args ::= ID | ID COMA dec_call_args | ; 

/*Aqui pretendo construir la finalización de los metodos que puedan retornar, sintácticamente
no influye que se pueda construir un método void con return ya que eso se comprueba en el  A. semántico*/
dec_return ::= RETURN dec_exp PUNTOCOMA ;

/*Aqui pretendo implementar operaciones de tipo (x<3) && !true */
dec_exp ::= dec_exp MAS dec_exp_extra | dec_exp MENOS dec_exp_extra | dec_exp_extra;

dec_exp_extra ::= dec_exp_extra POR fin | dec_exp_extra DIV fin | dec_exp_aux;

dec_exp_aux ::=  dec_exp_aux OR fin | dec_exp_aux LOGICOS_B fin | dec_exp_aux RELACIONALES fin| dec_exp_aux DISTINTO fin |fin ;

fin ::= MENOS fin| LOGICOS_U fin | PAR_OP dec_exp PAR_CL | NUM | ID | type_boolean;

/*Estructura de símbolos terminales */
type_methods ::= INT | BOOLEAN | VOID;

type_vars ::= INT | BOOLEAN ;

type_boolean ::= TRUE | FALSE;

