package teoria_automatas;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Hashtable;


parser code {:

public void report_error(String message, Object info) {

        StringBuffer m = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la linea "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", columna "+(s.right+1));
            }
        }

        m.append(" : "+message);

        System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void syntax_error(Symbol s){
        System.out.println("Error recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error no recuperable de sintaxis: "+s.value+" Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

:}

action code {:

:}

non terminal programa, dec_metodos, metodos, dec_args, cuerpo_metodo, dec_for, dec_ops, type_boolean, for_st_aux;
non terminal dec_asigs_ops, type_methods, type_vars,dec_for_loop, dec_asigs, dec_asigs_aux, dec_call,for_st_arrays, dec_exp;
non terminal dec_return, cuerpo_for, for_st_1, for_st_2, for_st_3, init_for, dec_call_args, dec_asignaciones, dec_call_ops, type_ops;

terminal String LL_OP, LL_CL, FOR ,ID, RETURN, PUNTOCOMA, NUM, PUNTO, NULL, OR, DISTINTO;
terminal String RELACIONALES, ASIGNACION, INCREMENT, PAR_OP, PAR_CL, COMA, POR, DIV, MENOS, MAS;
terminal String BEGIN_METODOS, LOGICOS_B, LOGICOS_U, BOOLEAN, TRUE, FALSE, INT, VOID;

precedence left MENOS;
precedence left MAS;
precedence left POR;
precedence right DIV;
precedence right RELACIONALES;
precedence right DISTINTO;
precedence right LOGICOS_B;
precedence right OR;
precedence right LOGICOS_U;

/*Inicio de la gramática*/
programa ::= dec_metodos ;

/*Para poder generar los metodos de 1 a N veces*/
dec_metodos ::= metodos | metodos dec_metodos;

/*Declaracion de metodos*/
metodos ::= BEGIN_METODOS type_methods ID PAR_OP dec_args PAR_CL LL_OP cuerpo_metodo LL_CL;
            
/*Argumentos de los métodos de 1 a N veces o ninguna*/
dec_args ::= type_vars ID | type_vars ID COMA dec_args | ;

/*El cuerpo de los metodos es lo que queramos meterle dentro*/
cuerpo_metodo ::= dec_asigs_ops dec_for_loop dec_call_ops dec_return;
       

/*Repeticiones de for 1 muchas o ninguna*/
dec_for_loop ::= dec_for | ;

/*Realizamos aqui la declaracion de uno o muchos bucles for uno dentro de otro*/
dec_for ::= FOR PAR_OP init_for PAR_CL LL_OP cuerpo_for dec_for LL_CL
           | FOR PAR_OP init_for PAR_CL LL_OP cuerpo_for LL_CL ;

/*El contenido del bucle (   A  ; B ;  C ) donde A = for_st_1, B = for_st_2 y C = for_st_3 */
init_for ::= for_st_1 PUNTOCOMA for_st_2 PUNTOCOMA for_st_3 ;

for_st_1 ::=  type_vars ID ASIGNACION for_st_aux | ID ASIGNACION for_st_aux ;

for_st_aux ::= ID | NUM;

for_st_2 ::= ID RELACIONALES for_st_arrays;

for_st_arrays ::= ID PUNTO ID | ID;

for_st_3 ::= ID INCREMENT;

/* Contenido del bucle for (Hay que meter asignaciones, llamadas y )*/
cuerpo_for ::= dec_asigs_ops type_ops;

/* Asignaciones, declaraciones to padentro tipo int a = 0;  boolean asdf = true; o int a; */
dec_asigs_ops ::= dec_asigs dec_asigs_ops |  ;


dec_asigs ::= type_vars ID dec_asignaciones
                | type_vars dec_call_args PUNTOCOMA;

dec_asignaciones ::= ASIGNACION dec_asigs_aux PUNTOCOMA
                | ASIGNACION ID PUNTOCOMA 
                | ASIGNACION ID dec_call;

/*Aqui pretendo construir sintácticamente las llamadas tipo a = calculo(val) o mostrartal(e, a )*/ 
dec_call_ops ::= dec_call dec_call_ops | ;


dec_call ::=  ID PAR_OP dec_call_args PAR_CL PUNTOCOMA 
             | PAR_OP dec_call_args PAR_CL PUNTOCOMA 
             | ID dec_asignaciones;

          
/* Construcciones de argumentos de llamadas a metodos a, b, c o a o lambda*/
dec_call_args ::= ID | ID COMA dec_call_args | ; 


/*Aqui pretendo construir la finalización de los metodos que puedan retornar, sintácticamente
no influye que se pueda construir un método void con return ya que eso se comprueba en el  A. semántico*/
dec_return ::= RETURN dec_ops | ;



/*Aqui pretendo implementar operaciones de tipo (x<3) && !true */
dec_ops ::= dec_exp PUNTOCOMA ; 

type_ops ::= dec_exp PUNTOCOMA | ;

dec_exp ::= NUM
            | ID
            | type_boolean
            | LOGICOS_U dec_exp
            | dec_exp MAS dec_exp
            | dec_exp POR dec_exp
            | dec_exp DIV dec_exp
            | dec_exp MENOS dec_exp
            | dec_exp RELACIONALES dec_exp
            | dec_exp LOGICOS_B dec_exp
            | dec_exp DISTINTO dec_exp
            | dec_exp OR dec_exp
            | PAR_OP dec_exp PAR_CL;

/*Estructura de símbolos terminales */

type_methods ::= INT | BOOLEAN | VOID;

type_vars ::= INT | BOOLEAN;

dec_asigs_aux ::= NUM | type_boolean;

type_boolean ::= TRUE | FALSE;

